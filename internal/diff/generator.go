package diff

import (
	"fmt"
	"strings"
	"time"

	"github.com/akmalulginan/datara/internal/state"
)

// Generator menangani pembuatan diff antara dua schema
type Generator struct {
	config *Config
}

// Config menyimpan konfigurasi untuk generator
type Config struct {
	Charset   string
	Collation string
	Engine    string
}

// NewGenerator membuat instance baru dari Generator
func NewGenerator(config *Config) *Generator {
	if config == nil {
		config = &Config{
			Charset:   "utf8mb4",
			Collation: "utf8mb4_unicode_ci",
			Engine:    "InnoDB",
		}
	}
	return &Generator{config: config}
}

// GenerateDiff membuat diff antara dua schema
func (g *Generator) GenerateDiff(current, desired *state.SchemaState) (string, error) {
	var statements []string

	// 1. Handle dropped tables
	for tableName := range current.Tables {
		if _, exists := desired.Tables[tableName]; !exists {
			stmt := fmt.Sprintf("DROP TABLE `%s`;", tableName)
			statements = append(statements, stmt)
		}
	}

	// 2. Handle new and modified tables
	for tableName, desiredTable := range desired.Tables {
		if currentTable, exists := current.Tables[tableName]; !exists {
			// New table
			stmt, err := g.generateCreateTable(desiredTable)
			if err != nil {
				return "", err
			}
			statements = append(statements, stmt)
		} else {
			// Existing table - check for modifications
			stmts, err := g.generateAlterTable(currentTable, desiredTable)
			if err != nil {
				return "", err
			}
			statements = append(statements, stmts...)
		}
	}

	if len(statements) == 0 {
		return "", nil // No changes
	}

	// Wrap in transaction
	return fmt.Sprintf("-- Generated by Datara at %s\n\nBEGIN;\n\n%s\n\nCOMMIT;\n",
		time.Now().Format("2006-01-02 15:04:05"),
		strings.Join(statements, "\n\n")), nil
}

// generateCreateTable membuat statement CREATE TABLE
func (g *Generator) generateCreateTable(table state.Table) (string, error) {
	var b strings.Builder

	fmt.Fprintf(&b, "CREATE TABLE `%s` (\n", table.Name)

	// Columns
	var columnDefs []string
	for _, col := range table.Columns {
		def := fmt.Sprintf("  `%s` %s", col.Name, col.Type)
		if !col.Nullable {
			def += " NOT NULL"
		}
		if col.AutoIncrement {
			def += " AUTO_INCREMENT"
		}
		if col.DefaultValue != nil {
			def += fmt.Sprintf(" DEFAULT %v", col.DefaultValue)
		}
		columnDefs = append(columnDefs, def)
	}

	// Constraints
	for _, constraint := range table.Constraints {
		columnDefs = append(columnDefs, fmt.Sprintf("  %s", constraint.Def))
	}

	b.WriteString(strings.Join(columnDefs, ",\n"))
	b.WriteString("\n)")

	// Table options
	fmt.Fprintf(&b, " ENGINE=%s", g.config.Engine)
	fmt.Fprintf(&b, " DEFAULT CHARSET=%s", g.config.Charset)
	fmt.Fprintf(&b, " COLLATE=%s;", g.config.Collation)

	// Indexes (created after table)
	for _, idx := range table.Indexes {
		unique := ""
		if idx.Unique {
			unique = "UNIQUE "
		}
		fmt.Fprintf(&b, "\n\nCREATE %sINDEX `%s` ON `%s` (%s);",
			unique, idx.Name, table.Name,
			strings.Join(quoteColumns(idx.Columns), ", "))
	}

	return b.String(), nil
}

// generateAlterTable membuat statements ALTER TABLE untuk modifikasi
func (g *Generator) generateAlterTable(current, desired state.Table) ([]string, error) {
	var statements []string

	// 1. Handle column changes
	for colName, desiredCol := range desired.Columns {
		if currentCol, exists := current.Columns[colName]; !exists {
			// New column
			stmt := fmt.Sprintf("ALTER TABLE `%s` ADD COLUMN `%s` %s",
				desired.Name, colName, g.generateColumnDef(desiredCol))
			statements = append(statements, stmt)
		} else if !columnsEqual(currentCol, desiredCol) {
			// Modified column
			stmt := fmt.Sprintf("ALTER TABLE `%s` MODIFY COLUMN `%s` %s",
				desired.Name, colName, g.generateColumnDef(desiredCol))
			statements = append(statements, stmt)
		}
	}

	// 2. Handle dropped columns
	for colName := range current.Columns {
		if _, exists := desired.Columns[colName]; !exists {
			stmt := fmt.Sprintf("ALTER TABLE `%s` DROP COLUMN `%s`",
				desired.Name, colName)
			statements = append(statements, stmt)
		}
	}

	// 3. Handle index changes
	for idxName, desiredIdx := range desired.Indexes {
		if currentIdx, exists := current.Indexes[idxName]; !exists {
			// New index
			unique := ""
			if desiredIdx.Unique {
				unique = "UNIQUE "
			}
			stmt := fmt.Sprintf("CREATE %sINDEX `%s` ON `%s` (%s)",
				unique, idxName, desired.Name,
				strings.Join(quoteColumns(desiredIdx.Columns), ", "))
			statements = append(statements, stmt)
		} else if !indexesEqual(currentIdx, desiredIdx) {
			// Modified index - drop and recreate
			statements = append(statements,
				fmt.Sprintf("DROP INDEX `%s` ON `%s`", idxName, desired.Name))
			unique := ""
			if desiredIdx.Unique {
				unique = "UNIQUE "
			}
			stmt := fmt.Sprintf("CREATE %sINDEX `%s` ON `%s` (%s)",
				unique, idxName, desired.Name,
				strings.Join(quoteColumns(desiredIdx.Columns), ", "))
			statements = append(statements, stmt)
		}
	}

	// 4. Handle dropped indexes
	for idxName := range current.Indexes {
		if _, exists := desired.Indexes[idxName]; !exists {
			stmt := fmt.Sprintf("DROP INDEX `%s` ON `%s`",
				idxName, desired.Name)
			statements = append(statements, stmt)
		}
	}

	// Add semicolons
	for i := range statements {
		statements[i] += ";"
	}

	return statements, nil
}

// generateColumnDef generates the column definition part of SQL
func (g *Generator) generateColumnDef(col state.Column) string {
	def := col.Type
	if !col.Nullable {
		def += " NOT NULL"
	}
	if col.AutoIncrement {
		def += " AUTO_INCREMENT"
	}
	if col.DefaultValue != nil {
		def += fmt.Sprintf(" DEFAULT %v", col.DefaultValue)
	}
	return def
}

// Helper functions

func columnsEqual(a, b state.Column) bool {
	return a.Type == b.Type &&
		a.Nullable == b.Nullable &&
		a.AutoIncrement == b.AutoIncrement &&
		a.DefaultValue == b.DefaultValue
}

func indexesEqual(a, b state.Index) bool {
	if a.Unique != b.Unique || len(a.Columns) != len(b.Columns) {
		return false
	}
	for i := range a.Columns {
		if a.Columns[i] != b.Columns[i] {
			return false
		}
	}
	return true
}

func quoteColumns(columns []string) []string {
	quoted := make([]string, len(columns))
	for i, col := range columns {
		quoted[i] = fmt.Sprintf("`%s`", col)
	}
	return quoted
}
